#pragma kernel ComputeDensityPressure
#pragma kernel ComputeForces
#pragma kernel Integrate
struct Particle
{
    float pressure;
    float density;
    float3 currentForce;
    float3 velocity;
    float3 position;
};

RWStructuredBuffer<Particle> _particles;

//Variable Declarations
float particleMass=2.0;
float viscosity=200;
float gasConstant=2000;
float restDensity=300;
float boundDamping=-0.5;
float radius=2;
float radius2=4;
float radius3=8;
float radius4=16;
float radius5=32;
float pi = 3.1415926535897932384626433832795028841971;
int particleLength;
float timestep;
float3 boxSize;
float3 spherePos;
float sphereRadius;

//Smoothing Functions for Compute Forces
float StdKernel(float distanceSquared)
{
    float x = 1.0f - distanceSquared / radius2;
    return 315.f / (64.f * pi * radius3) * x * x * x;

}

float SpikyKernelFirstDerivative(float distance)
{
    float x = 1.0f - distance / radius;
    return -45.f / (pi * radius4) * x * x;

}

float SpikyKernelSecondDerivative(float distance)
{
    float x = 1.0f - distance / radius;
    return 90.f / (pi * radius5) * x;

}

float3 SpikyKernelGradient(float distance, float3 direction)
{
    return SpikyKernelFirstDerivative(distance) * direction;

}



//pressure : when two particles are too close to each other
//they push back each other.

//viscosity : Bind the particles 

[numthreads(100, 1, 1)]
void ComputeDensityPressure(uint3 id : SV_DISPATCHTHREADID)
{
    float3 origin = _particles[id.x].position;
    float sum = 0;
    
    for (int i = 0; i < particleLength; i++)
    {
        float3 diff = origin - _particles[i].position;
        float distanceSquared = dot(diff, diff);
        
        if (radius2 * 0.004 > distanceSquared * 0.004)
        {
            
            //this code is newly added.
            float x = (radius2 * 0.004) - (distanceSquared * 0.004);
            //applying smoothing kernel
            //the closer the neighbor is , the higher density.
            //higher density -> higher pressure -> moving particles back to each other.
            sum += StdKernel(distanceSquared * 0.004);
        }

    }
    
    _particles[id.x].density = sum * particleMass + 0.000001f;
    _particles[id.x].pressure = gasConstant * (_particles[id.x].density - restDensity);

    
    //this code is newly added
    if (_particles[id.x].pressure <= 0)
        _particles[id.x].pressure = 0;
}


[numthreads(100, 1, 1)]
void ComputeForces(uint3 id : SV_DISPATCHTHREADID)
{
    float3 origin = _particles[id.x].position;
    float density2 = _particles[id.x].density * _particles[id.x].density;
    float mass2 = particleMass * particleMass;
    float3 pressure = float3(0, 0, 0); // to be calculated
    float3 visc = float3(0, 0, 0); // to be calculated
    
    for (int i = 0; i < particleLength; i++)
    {
        if (origin.x == _particles[i].position.x && origin.y == _particles[i].position.y && origin.z == _particles[i].position.z)
        {
            continue;
        }
        
        float dist = distance(_particles[i].position, origin);
        if (dist < radius * 2)
        {
            float3 pressureGradientDirection = normalize(_particles[id.x].position - _particles[i].position);
            
            float3 _pressureContribution = mass2 * SpikyKernelGradient(dist, pressureGradientDirection);
            _pressureContribution *= (_particles[id.x].pressure / density2 + _particles[i].pressure / (_particles[i].density * _particles[i].density));

            float3 _viscosityContribution = viscosity * mass2 * (_particles[i].velocity - _particles[id.x].velocity) / _particles[i].density;
            _viscosityContribution *= SpikyKernelSecondDerivative(dist);
            
            pressure += _pressureContribution;
            visc += _viscosityContribution;

        }
        
        

    }

    _particles[id.x].currentForce = float3(0, -9.81 * particleMass, 0) - pressure + visc;

    float3 colDir = _particles[id.x].position - spherePos;
    if (length(colDir) < sphereRadius)
    {
        _particles[id.x].currentForce += colDir * 300;
    }

}

//this function is called once for every single particle
[numthreads(100,1,1)]
void Integrate(uint3 id: SV_DiSPATCHTHREADID)
{
    //since F=ma, F/m ecomes accelration.
    // velocity = initial velocity + Accelration * timestep
    // time step is a key factor for accurate simulation but also for the perforamnce 
    
    float3 vel = _particles[id.x].velocity + ((_particles[id.x].currentForce / particleMass) * timestep);
    
    //change of position = velocity * timestep
    _particles[id.x].position += vel * timestep;
    
    
    
    float3 topRight = boxSize / 2;
    float3 bottomLeft = -boxSize / 2;
    
    //Min Boundary Enforcements
    if (_particles[id.x].position.x - radius < bottomLeft.x)
    {
        //when dampped to the boundary
        vel.x *= boundDamping;
        _particles[id.x].position.x = bottomLeft.x + radius;
    }
    
    if (_particles[id.x].position.y - radius < bottomLeft.y)
    {
        vel.y *= boundDamping;
        _particles[id.x].position.y = bottomLeft.y + radius;
    }
    
    if (_particles[id.x].position.z - radius < bottomLeft.z)
    {
        vel.z *= boundDamping;
        _particles[id.x].position.z = bottomLeft.z + radius;
    }
    
    
    //Max Boundary Enforcements
    if (_particles[id.x].position.x + radius > topRight.x)
    {
        //when dampped to the boundary
        vel.x *= boundDamping;
        _particles[id.x].position.x = topRight.x - radius;
    }
    
    if (_particles[id.x].position.y + radius > topRight.y)
    {
        vel.y *= boundDamping;
        _particles[id.x].position.y = topRight.y - radius;
    }
    
    if (_particles[id.x].position.z + radius > topRight.z)
    {
        vel.z *= boundDamping;
        _particles[id.x].position.z = topRight.z - radius;
    }
    
    //check the bounding box condition
    //when the particles go out of the box,
    // they bounce back.
    _particles[id.x].velocity = vel;
    
}
